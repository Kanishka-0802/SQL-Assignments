Assignment -7

 

 -- transactions-------------

/* 1. Basic Transaction — Commit / Rollback 
Create a table BankAccount with sample records. 
Write a transaction that transfers money from one account to another. 
If the source account balance becomes negative, roll back the transaction; otherwise 
commit. */

-- query :

create table BankAccount(Account_id int primary key,Acc_Name varchar(20),Balance int);

insert into BankAccount values
(101, 'Vanitha', 6700),
(201, 'Chandran', 100)


select * from BankAccount
drop table BankAccount

begin transaction
update BankAccount set Balance = Balance-8700 where Account_id =101


if((select Balance from BankAccount where Account_id=101)<0)
   begin
   print 'Transaction failed: insufficient funds'
   rollback transaction
   end
   else
   begin 
   update BankAccount set Balance = Balance+8700 where Account_id =201
   commit transaction
   print 'Transaction successful'
   end

/*
2. Using SAVEPOINT 
Insert three new records into a table Orders. 
Create a SAVEPOINT after each insert. 
Rollback only the second insert using the SAVEPOINT, then commit the remaining inserts. */

create table orders_6 (
    orderid int,
    pname varchar(50),
    price int
)

select * from Orders_6
begin transaction
insert into orders_6 values(1,'mobilecover',190)
save transaction sp1
insert into orders_6 values(2,'Earpods',490)
save transaction sp2
insert into orders_6 values(3,'sketchpencil',340)
save transaction sp3
insert into orders_6 values(4,'sketch',340)
save transaction sp4
rollback transaction sp2
commit transaction


/*3. Handling Errors with TRY…CATCH 
Write a transaction that updates prices in a Products table. 
Introduce a division-by-zero error inside the transaction. 
Use TRY…CATCH to rollback the transaction and log the error message in a separate 
ErrorLog table */

create table products_2(pid int,pname varchar(20),price int)
select * from products_2
select * from errorlog

begin try
    begin transaction
    insert into products_2 values (104, 'eraser', 30)
    declare @x int = 1/0
    update products_2 set price = 200 where pid = 102

    commit transaction;
    print 'transaction successful'
end try
begin catch
    print 'error occurred... rolling back transaction'

    if @@error > 0
       rollback transaction
    insert into errorlog (errormessage, errorseverity, errorstate)
    values (error_message(), error_severity(), error_state())
end catch



/*
4. Nested Transactions 
Create nested transactions: 
• Outer transaction inserts a customer 
• Inner transaction inserts an order for the customer 
• Force an error in the inner transaction 
Practice observing whether the outer transaction is committed or rolled back. 
*/
 select * from custs_1
 select * from orders_6

 begin transaction
 insert into custs_1 values(10,'sastika','Hyderabad')
 save transaction sp1
 begin try
 insert into orders_6 values(5,'pen',10)
 declare @x int=1/0
 print 'Inner transaction successful'
 end try
 begin catch 
 print 'error occurred.........'
 print 'error occurred in inner transaction'
  if @@trancount>0
  rollback transaction sp1
  end catch
  commit transaction
  print 'Outer transaction committed'


/*
5.Isolation Level – Dirty Read 
Use two sessions: 
• Session 1: Open a transaction, update a row, but don’t commit 
• Session 2: Use SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED and read 
the same row 
Check whether dirty reads are allowed. */

select * from test2

set transaction isolation level read uncommitted
begin transaction
select * from test2 where cid =2
waitfor delay '00:00:10'
select * from test2 where cid =2
commit

/*
6. Isolation Level – Non-repeatable Read 
Using two sessions: 
• Session 1 reads a row twice inside a transaction 
• Session 2 updates and commits the same row in between 
Observe changes and understand non-repeatable reads.
*/


set transaction isolation level read committed
begin transaction
select * from test2 where cid =2
waitfor delay '00:00:10'
select * from test2 where cid =2
commit transaction


--non - repeatable read-----------------
begin transaction
update test2 set cname='keerthi' 
where cid=2
commit
/*
7. Isolation Level – Phantom Read 
Create a table Sales. 
Using two sessions: 
• Session 1 selects rows between a range inside a transaction 
• Session 2 inserts a new row within the range and commits 
See if the first session sees new rows depending on isolation level. 
*/
-- window 1
select * from sales

set transaction isolation level read committed
begin transaction
select * from Sales where SaleAmount between 110000 and 300000
waitfor delay '00:00:10'
select * from Sales where SaleAmount between 110000 and 300000
commit transaction



----window 2
--7--

insert into Sales values (8,8, 'North', 155000.00,'2021-03-05')
commit


/*
 
8.Savepoint with Partial Rollback 
Inside a transaction: 
• Update 5 employee salaries 
• Create a savepoint after each update 
• Rollback to savepoint 3 
• Commit the rest 
Check which rows were updated finally. */

select * from employees_table
begin transaction
update employees_table set Salary = Salary + 1000 where EmployeeID = 8
save transaction sp1
update employees_table set Salary = Salary + 1000 where  EmployeeID = 1002
save transaction sp2
update employees_table set Salary = Salary + 1000 where  EmployeeID = 1003
save transaction sp3
update employees_table set Salary = Salary + 1000 where  EmployeeID = 1004
save transaction sp4
update employees_table set Salary = Salary + 1000 where  EmployeeID = 1005
save transaction sp5
rollback transaction sp3
commit transaction



/*
9.Insert multiple product records using a single transaction. 
Force an error in one insert (duplicate key or null value). 
Ensure that no records are inserted into the table. 
*/
 select * from products_1
 begin transaction
 begin try
    insert into products_1 values (109, 'Pen', 'Stationery')
    insert into products_1 values (110, 'Pencil', 'Stationery')
    insert into products_1 values (109, 'Notebook', 'Stationery')
    commit transaction;
    print 'All products inserted successfully'
end try
begin catch
    print 'Error occurred....'
    if @@trancount > 0
        rollback transaction
end catch




 /*
10.Savepoint in TRY…CATCH 
Inside a long transaction: 
• Insert 3 orders 
• Savepoint after each 
• Force an error before the third insert 
Use savepoint rollback to keep first 2 inserts.
*/
select * from orders_6
begin transaction
begin try
    insert into orders_6 values (201, 'Laptop', 750)
    save transaction sp1
    insert into orders_6 values (202, 'Tablet', 300)
    save transaction sp2
    declare @x int = 1/0
    insert into orders_6 values (203, 'Phone', 20000)
    save transaction sp3
    commit transaction
    print 'All orders inserted successfully'
end try
begin catch
    print 'Error occurred before 3rd insert'

    if @@trancount > 0
        rollback transaction sp2
        commit transaction
    print 'Transaction committed for 2 inserts'
end catch
